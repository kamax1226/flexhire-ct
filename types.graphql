Query currentUser: User


type ContractConnection {
  edges: [ContractEdge]
  nodes: [Contract]
  pageInfo: PageInfo!
  totalCount: Int
}

type User {
  additionalInvoiceText: String
  answers(jobId: Int): [Video!]
  apiAccess: Boolean
  apiKeys: [ApiKey!]
  appliedAt: DateTime
  avatarUrl: String
  backgroundCheckCompleted: Boolean
  blockPlatformAccessDueToUnpaidInvoicesDate: Boolean
  calendlyUrl: String
  canMakeOffer: Boolean
  canNotify: Boolean
  canRequestInterview: Boolean
  canSetupPayoutMethod: Boolean
  clientContracts(
    after: String
    before: String
    first: Int
    last: Int
    stage: String
  ): ContractConnection
  configuration: Configuration
  confirmedEmail: Boolean
  contractSigned: Boolean
  contracts(
    after: String
    before: String
    first: Int
    last: Int
  ): ContractConnection
  createdAt: DateTime
  directChatThreadId: Int
  displayDialogAfterSavingDraftTimesheet: Boolean
  email: String
  featureStepCompleted: Boolean!
  featured: Boolean
  firm: Firm
  firmRole: FirmRole
  firstName: String
  freelancerContracts(
    after: String
    before: String
    first: Int
    last: Int
  ): ContractConnection
  fullAddress: String
  hasActivePayoutMethod: Boolean
  hasInvitationContracts: Boolean
  hasInvoiceAccess: Boolean
  hasTeam: Boolean
  hidden: Boolean
  hireSourcedByClientMargin: Float @deprecated(reason: "use firm.billingPlan values")
  hireSourcedByFlexhireMargin: Float @deprecated(reason: "use firm.billingPlan values")
  id: ID!
  integrationName: String
  inviteMargin: Float @deprecated(reason: "use firm.billingPlan values")
  invitedToJob(jobId: Int, jobSlug: String): Boolean
  invoiceManager: User
  isFlexhireTeam: Boolean
  jobApplicationsCount: Int
  jobIncompatibilityReasons(jobId: Int, jobSlug: String): [String!]
  lastName: String
  lastSeenAt: DateTime
  location: String @deprecated(reason: "use country, fullAddress, city, region instead")
  managerContract: Contract
  managerInvitationMessage: String
  managesInvoicesFor: [Int!]
  minMarginUsd: Float @deprecated(reason: "use country, fullAddress, city, region instead")
  name: String
  passwordSetupRequired: Boolean
  payoutMethod: PayoutMethod
  payoutMethods: [PayoutMethod!]
  phone: String
  profile: Profile
  purchaseOrderNumber: String
  ratingCountHigh: Int
  ratingCountLow: Int
  ratingCountMedium: Int
  rawId: Int
  realUser: User
  references: [Reference!]
  remoteDebugCode: String
  resumeUrl: String
  roles: [UserRole!]!
  self: Boolean
  sendTimesheetReminders: Boolean
  skipped: Boolean
  status: String
  teamInvitationMessage: String
  termsOfServiceApproved: Boolean
  timezone: String
  timezoneName: String
  timezoneOffset: Int
  unconfirmedEmail: String
  updatedAt: DateTime
  userSkills: [UserSkill!]
  verified: Boolean
  video: Video
  webhooks: [Webhook!]
}

type ContractEdge {
  cursor: String!
  node: Contract
}

type Contract {
  allowTextualAnswers: Boolean
  annualCompensation: Money
  annualCompensationCents: Int
  answers: [Video!]
  applicantSource: String
  availabilityType: [String!]
  backgroundCheckStatus: String
  bookmarked: Boolean
  calendlyUrl: String
  checkrCandidateId: String
  city: String
  client: User
  clientAgreesTerms: Boolean
  clientRate: Money
  clientRejectionComments: String
  clientRejectionMessage: String
  clientRejectionReason: String
  contractFeedbacks: [ContractFeedback!]
  contractIntroductionSentAt: DateTime
  contractRequests: [ContractRequest!]
  country: String
  createdAt: DateTime!
  currency: String!
  dailyFee: Money
  defaultDistance: Float
  deletable: Boolean
  description: String
  disableMinUsdMarginLimit: Boolean
  discountId: Int
  enableTimesheets: Boolean
  endDate: Date
  estimatedNextSalaryPayoutDate: DateTime
  firmRole: String
  freelancer: User
  freelancerAgreesTerms: Boolean
  freelancerContactEmail: String
  freelancerEmail: String
  freelancerFeedback: String
  freelancerFirstName: String
  freelancerLastName: String
  freelancerMessage: String
  freelancerPhone: String
  freelancerRate: Money
  freelancerTimezoneName: String
  fullAddress: String
  hidden: Boolean
  hiringManager: User
  id: ID!
  inheritor: User
  interviewAcceptedAt: DateTime
  interviewDate: DateTime
  interviewDate1: DateTime
  interviewDate2: DateTime
  interviewDate3: DateTime
  interviewDate4: DateTime
  interviewNote: String
  interviewSchedulingMethod: String
  interviewTimezone: String
  interviewerEmail: String
  interviewerName: String
  interviewerRole: String
  invitationType: String
  invitedBy: User
  invitedToApplyAt: DateTime
  job: Job
  jobApplicationNotifiedToAdminsAt: DateTime
  jobApplicationReminderSentAt: DateTime
  jobApplicationSentAt: DateTime
  jobApplicationSentByFreelancerAt: DateTime
  jobOpportunitySentAt: DateTime
  jobTimezone: String
  lastInteractionAt: DateTime
  latitude: Float
  locationType: String
  longitude: Float
  managedOffPlatform: Boolean
  margin: Float
  minClientRate: Float
  minDateToInvoiceNextSalary: DateTime
  minMarginUsd: Float
  negativeFeedbackCount: Int
  nextSalaryInvoiceDate: DateTime
  notifyChanges: Boolean
  offerNote: String
  paymentMode: String
  paymentsEnabled: Boolean
  positionTypes: [String!]
  positiveFeedbackCount: Int
  postInterviewRemindersSentAt: DateTime
  previousStatus: String
  profileJobIncompatibilityReasons: [String!]
  projectLength: String
  projectLengthInMonths: Int
  projectSubmission: ProjectSubmission
  purchaseOrderNumber: String
  rateMode: String
  rawId: Int
  ref: String
  referer: User
  refererUrl: String
  referralOpportunitySentAt: DateTime
  region: String
  requestBackground: Boolean
  requestsStatus: ContractRequestsStatus
  requireTimesheetApprovalForPayments: Boolean
  signableDocuments: [SignableDocument!]
  sourcedByClient: Boolean
  startDate: Date
  status: ContractStatus!
  stripePlanId: String
  stripeProductId: String
  stripeSubscriptionId: String
  tags: [Tag!]
  textualAnswers: [Answer!]
  token: String
  updatedAt: DateTime!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Job implements Node {
  activeJobIntegrationsNames: [String!]
  allowTextualAnswers: Boolean!
  applications(filters: CandidatesFilters): ApplicationsResults
  autoRenew: Boolean
  autoSendScreeningRequests: Boolean
  automaticallyNotifyCandidates: Boolean
  availabilityType: String
  candidates(
    after: String
    before: String
    filters: CandidatesFilters
    first: Int
    last: Int
  ): CandidateConnection
  candidatesToNotify: [CandidateToNotify!]
  city: String
  clientRate: Money
  clientRateCents: Int
  contracts(
    after: String
    before: String
    filters: ContractsFilters
    first: Int
    last: Int
  ): ContractConnection
  country: String
  createdAt: DateTime
  defaultDistance: Float
  description: String
  descriptionExperience: String
  descriptionResponsibilities: String
  expiresAt: DateTime
  freelancerRate: Money
  freelancerRateCents: Int
  freelancerSubtypes: [FreelancerSubtype!]! @deprecated(reason: "use job.jobSubtypes")
  freelancerType: FreelancerType
  fullAddress: String
  hiringManager: User
  hiringManagerType: String
  id: ID!
  internalRecruiter: User
  jobCountries: [String!]!
  jobIntegrations: [JobIntegration!]
  jobSkills: [JobSkill!]!
  jobSocialIntegrations: [String!]
  jobSubtypes: [JobSubtype!]!
  jobTimezone: String
  locationLatitude: Float
  locationLongitude: Float
  locationType: String
  margin: Float
  markup: Float
  minClientRate: Money
  minClientRateCents: Int
  minFreelancerRate: Money
  minFreelancerRateCents: Int
  minMarginUsd: Float
  numberOfHires: Int
  positionTypes: [Position!]!
  project: Project
  projectLengthInMonths: Int
  questions: [Question!]
  rateMode: String
  rawId: Int
  recruiters: [User!]
  referralBounty: Money
  region: String
  requiredExperienceYears: Int
  screening(filters: CandidatesFilters): ApplicationsResults
  screeningRequestMessageTemplate: String
  slug: String
  status: String
  timezoneRange: Int
  timezoneValue: Int
  title: String!
  updatedAt: DateTime
  user: User
}

type Question implements Node {
  answersCount: Int
  description: String
  freelancerSubtypes: [FreelancerSubtype!]
  freelancerTypes: [FreelancerType!]
  id: ID!
  jobsCount: Int
  rawId: Int!
  skills: [Skill!]
  status: String
  tags: [Tag!]
  title: String
}

type UserSkill implements Node {
  experience: Int
  id: ID!
  skill: Skill
}

type Skill implements Node {
  custom: Boolean
  customUser: User
  freelancerTypes: [FreelancerType!]
  id: ID!
  name: String
  rawId: Int
  slug: String
}

type Profile implements Node {
  addressRecipient: String
  allowScreening: Boolean
  annualCompensation: Money
  availability: String
  availabilityType: [String!]
  availableAt: DateTime
  canWorkInTheUs: Boolean
  city: String
  cityRecipient: String
  clientRate: Money
  country: String
  countryRecipient: String
  createdAt: DateTime
  freelancerRate: Money
  freelancerSubtypes: [FreelancerSubtype!]
  freelancerType: FreelancerType
  fullAddress: String
  id: ID!
  jobTypes: [JobType!]!
  jobsHaveCodeTests: Boolean
  lastMessagedAt: DateTime
  locationBounds0: Float
  locationBounds1: Float
  locationBounds2: Float
  locationBounds3: Float
  locationBounds4: Float
  locationLatitude: Float
  locationLongitude: Float
  managedTeamSize: Int
  openToOpportunities: Boolean
  region: String
  screeningFeedback: String
  screeningRequiresProject: Boolean
  slug: String
  stateRecipient: String
  status: String
  taxId: String
  textIntroduction: String
  totalExperience: Int
  updatedAt: DateTime
  urlBlog: String
  urlDribbble: String
  urlGithub: String
  urlLinkedin: String
  usCitizen: Boolean
  visibility: String
  zip: String
}
